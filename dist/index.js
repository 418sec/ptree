function getSegments(a){let b;if("string"==typeof a){if(!a.length)return[];b=a.split(".")}else b=a.map(a=>{const b=typeof a;return"string"==b||"number"==b?a:"function"==b?a():void 0});return b}function equalArrays(c,a){return c.length==a.length&&c.every((b,c)=>b===a[c])}const PTree=function(a){if("object"!=typeof a)throw"PTree: Constructor received atomic value as root";this._root=a,this.get=function(a){const b=typeof a;if("string"!=b&&!Array.isArray(a))throw`PTree: String or Array expected, received: ${b}`;if(void 0!==this._root[a])return this._root[a];let c=getSegments(a),d=this._root;for(let b=0;b<c.length;b++){const a=c[b];if(d=d[a],void 0===d)return}return d},this.keys=function(a){const b=typeof this._root;if("object"!=b&&!Array.isArray(this._root))throw`PTree: Object or Array expected, received: ${b}`;let c=[];if("object"==b&&!Array.isArray(this._root)){let a=Object.keys(this._root);c=a.reduce((a,b)=>{const c=this._root[b];return"object"==typeof c?a.concat(new PTree(c).keys(b)):a.concat(b)},[])}else if(Array.isArray(this._root))c=this._root.reduce((a,b,c)=>"object"==typeof b?a.concat(new PTree(b).keys(c.toString())):a.concat(c.toString()),[]);else throw`Tried to get keys of atomic value`;return void 0!==a&&(c=c.map(b=>`${a}.${b}`)),c},this.set=function(a,b){const c=typeof a;if("string"!=c&&!Array.isArray(a))throw`PTree: String or Array expected, received: ${c}`;let d=getSegments(a),e=this._root;for(let c=0;c<d.length;c++){const a=e,f=d[c];if(c<d.length-1)e=e[f];else if("object"==typeof e)e[f]=b;else throw`PTree: Tried to set property of atomic value`;e===void 0&&(a[f]=/^[0-9]+$/.test(f)?[]:{},e=a[f])}},this.values=function(){return this.fromKeys(this.keys())},this.fromKeys=function(a){return a.map(a=>this.get(a))},this.filterKeys=function(a){return this.keys().filter(b=>a(this.get(b)))},this.flatten=function(){let a={};return this.keys().forEach(b=>{a[b]=this.get(b)}),a},this.equal=function(a){if(typeof this._root!=typeof a)return!1;const b=new PTree(a),c=this.keys(),d=b.keys();if(!equalArrays(c,d))return!1;const e=this.fromKeys(c),f=b.fromKeys(d);return equalArrays(e,f)},this.findKey=function(a){return this.keys().find(b=>a(this.get(b)))},this.map=function(a){const b=this.keys();let c;Array.isArray(this._root)?c=[]:"object"==typeof this._root&&(c={});let d=new PTree(c);return b.forEach(b=>{let c=this.get(b);d.set(b,a(c))}),c},this.validate=function(a){for(const b of a){if(!b.path)throw"PTree: Invalid path in validation function";if("*"===b.path){a.push(...this.keys().map(a=>({path:a,optional:b.optional,rules:b.rules})));continue}const c=this.get(b.path);if(c===void 0&&!b.optional)return!1;if(void 0===c&&b.optional)return!0;if(b.rules)for(const a of b.rules)if(!a(c))return!1}return!0}};module.exports=function(a){return new PTree(a)};