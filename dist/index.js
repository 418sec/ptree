"use strict";Object.defineProperty(exports,"__esModule",{value:!0});function getSegments(a){let b=[];if("string"==typeof a){if(!a.length)return[];b=a.split(".")}else b=a.map(a=>"function"==typeof a?a():"string"==typeof a||"number"==typeof a?a:"");return b}function equalArrays(c,a){return c.length==a.length&&c.every((b,c)=>b===a[c])}class PTree{constructor(a){this.root=a}get(a){if(("string"==typeof a||"number"==typeof a)&&this.root[a]!==void 0)return this.root[a];const b=getSegments(a);let c=this.root;for(let d=0;d<b.length;d++){const a=b[d];if(c=c[a],void 0===c)return}return c}keys(a){let b=[];if(!Array.isArray(this.root)){let a=Object.keys(this.root);b=a.reduce((a,b)=>{const c=this.root[b];return"object"==typeof c?a.concat(new PTree(c).keys(b)):a.concat(b)},[])}else if(Array.isArray(this.root))b=this.root.reduce((a,b,c)=>"object"==typeof b?a.concat(new PTree(b).keys(c.toString())):a.concat(c.toString()),[]);else throw`Tried to get keys of atomic value`;return void 0!==a&&(b=b.map(b=>`${a}.${b}`)),b}set(a,b){let c=getSegments(a),d=this.root;for(let e=0;e<c.length;e++){const a=d,f=c[e];if(e<c.length-1)d=d[f];else if("object"==typeof d)d[f]=b;else throw`PTree: Tried to set property of atomic value`;d===void 0&&(a[f]=/^[0-9]+$/.test(f.toString())?[]:{},d=a[f])}}values(){return this.fromKeys(this.keys())}fromKeys(a){return a.map(a=>this.get(a))}filterKeys(a){return this.keys().filter(b=>a(this.get(b)))}flatten(){let a={};return this.keys().forEach(b=>{a[b]=this.get(b)}),a}equal(a){if(typeof this.root!=typeof a)return!1;const b=new PTree(a),c=this.keys(),d=b.keys();if(!equalArrays(c,d))return!1;const e=this.fromKeys(c),f=b.fromKeys(d);return equalArrays(e,f)}findKey(a){return this.keys().find(b=>a(this.get(b)))}map(a){const b=this.keys();let c;Array.isArray(this.root)?c=[]:"object"==typeof this.root&&(c={});let d=new PTree(c);return b.forEach(b=>{let c=this.get(b);d.set(b,a(c))}),c}validate(a){for(const b of a){if(!b.path)throw"PTree: Invalid path in validation function";if("*"===b.path){a.push(...this.keys().map(a=>({path:a,optional:b.optional,rules:b.rules,preTransform:b.preTransform,postTransform:b.postTransform})));continue}let c=this.get(b.path);if(b.preTransform){for(const a of b.preTransform)this.set(b.path,a(c,this.root));c=this.get(b.path)}if(void 0===c&&!b.optional)return!1;if(void 0===c&&b.optional)return!0;if(b.rules)for(const a of b.rules)if("function"==typeof a){const b=a(c,this.root);if(!0===b)continue;return b}if(b.postTransform)for(const a of b.postTransform)this.set(b.path,a(c,this.root))}return!0}copy(){const a=this.keys();let b={};Array.isArray(this.root)&&(b=[]);let c=new PTree(b);return a.forEach(a=>{c.set(a,this.get(a))}),c.root}}exports.default=PTree;